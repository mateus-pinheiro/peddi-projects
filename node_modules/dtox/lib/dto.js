'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Base DTO classes
 *
 * @author Patrick Stadler <patrick.stadler@gmail.com>
 * @author Michael Weibel <michael.weibel@gmail.com>
 */

var _require = require('./errors'),
    MappingError = _require.MappingError,
    MissingPropertyError = _require.MissingPropertyError,
    InvalidArgumentError = _require.InvalidArgumentError,
    InvalidPropertyError = _require.InvalidPropertyError;

/**
 * Base DTO class
 */


var BaseDTO = function () {
  /**
   * Construct a new BaseDTO
   *
   * @param {Object} data typically a JSON object
   * @param {Object} mapping
   *
   * @throws MappingError if mapping is missing
   * @throws MissingPropertyError if a property is missing
   */
  function BaseDTO(data, mapping) {
    _classCallCheck(this, BaseDTO);

    var mappingKeys = Object.keys(mapping || {});

    if (mappingKeys.length === 0) {
      throw new MappingError('Mapping required');
    }

    mappingKeys.forEach(function (k) {
      var options = mapping[k].options || {};
      var key = options.key || k;
      var value = void 0;

      if (options.callback) {
        value = options.callback(data);
      }
      if (value === undefined) {
        value = data[key] !== undefined ? data[key] : options.default;
      }

      if (value === undefined) {
        throw new MissingPropertyError('Required property "' + key + '" is missing');
      }

      this[k] = mapping[k].fn(value);
    }, this);

    this.__RAW__ = data;
  }

  /**
   * Returns mapped values as an own object.
   *
   * @returns {Object}
   */


  _createClass(BaseDTO, [{
    key: 'toJSON',
    value: function toJSON() {
      var values = {};

      Object.keys(this).filter(function (key) {
        return key !== '__RAW__';
      }).forEach(function (key) {
        values[key] = this[key];
      }, this);

      return values;
    }
  }]);

  return BaseDTO;
}();

/**
 * Base List DTO class
 */


var BaseListDTO = function () {
  /**
   * Construct a new BaseListDTO
   *
   * @param {Object}  data     typically a JSON array
   * @param {BaseDTO} DTOClass to be applied on list elements
   *
   * @throws InvalidArgumentError if DTOClass is not inheriting from BaseDTO
   * @throws InvalidPropertyError if a property is missing or the response is not of type Array
   */
  function BaseListDTO(data, DTOClass) {
    _classCallCheck(this, BaseListDTO);

    if (!(DTOClass && DTOClass.prototype instanceof BaseDTO)) {
      throw new InvalidArgumentError('Valid DTO class required');
    }

    if (!Array.isArray(data)) {
      throw new InvalidPropertyError('Property of type array required');
    }

    this.items = data.map(function mapItems(item) {
      return new DTOClass(item);
    });

    this.__RAW__ = data;
  }

  /**
   * Iterator protocol conformity.
   * @returns {Array}
   */


  _createClass(BaseListDTO, [{
    key: Symbol.iterator,
    value: function value() {
      return this.items[Symbol.iterator]();
    }

    /**
     * Returns the items when serialising.
     *
     * @returns {Array}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.items;
    }
  }]);

  return BaseListDTO;
}();

var methods = ['concat', 'every', 'filter', 'forEach', 'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight', 'slice', 'some'];

/**
 * Standard array helper methods
 *
 * `#concat()`, `#every()`, `#filter()`, `#forEach()`, `#indexOf()`, `#join()`,
 * `#lastIndexOf()`, `#map()`, `#reduce()`, `#reduceRight()`, `#slice()`, `#some()`
 *
 * @param {*}
 * @returns {*}
 */
methods.forEach(function (method) {
  BaseListDTO.prototype[method] = function () {
    return [][method].apply(this.items || [], arguments);
  };
});

module.exports = {
  BaseDTO: BaseDTO,
  BaseListDTO: BaseListDTO
};